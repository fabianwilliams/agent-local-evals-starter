using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.SemanticKernel;
using Microsoft.SemanticKernel.Agents;
using Microsoft.SemanticKernel.Agents.Chat;
using Microsoft.SemanticKernel.ChatCompletion;
using Microsoft.SemanticKernel.Connectors.Ollama;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;

internal class TwoAgentProgram
{
    private static IConfiguration? _configuration;
    private static ILogger<TwoAgentProgram>? _logger;
    
    private static async Task Main(string[] args)
    {
        // Initialize configuration and logging
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
        _configuration = configurationBuilder.Build();

        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddConsole();
        });
        _logger = loggerFactory.CreateLogger<TwoAgentProgram>();

        Console.WriteLine("üöÄ Starting FABS - Two-Agent Mode (Writer ‚Üí CopyEditor)");
        Console.WriteLine(new string('=', 70));

        try
        {
            await RunTwoAgentBlogGenerationAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Fatal error: {ex.Message}");
            Environment.Exit(1);
        }
    }

    private static async Task RunTwoAgentBlogGenerationAsync()
    {
        // Initialize kernel
        var kernel = CreateKernel();
        
        // Load paths and template
        var draftsFolder = _configuration?["Paths:DraftsFolder"] ?? "";
        var templateFolder = _configuration?["Paths:TemplateFolder"] ?? "";
        var finalDraftFolder = _configuration?["Paths:FinalDraftFolder"] ?? "";

        if (!Directory.Exists(draftsFolder))
        {
            Console.WriteLine($"‚ùå Drafts folder not found: {draftsFolder}");
            return;
        }

        // Load template
        var template = await LoadTemplateAsync(templateFolder);
        
        // Create the two agents
        var writerAgent = CreateWriterAgent(kernel, template);
        var copyEditorAgent = CreateCopyEditorAgent(kernel);
        
        // Simple selection strategy: Writer first, then CopyEditor, then done
        KernelFunction selectionFunction = AgentGroupChat.CreatePromptFunctionForStrategy(
            """
            Look at the RESPONSE and choose the next agent:
            - If no blog post exists yet, choose "WriterAgent"
            - If WriterAgent just responded with a blog post, choose "CopyEditorAgent"  
            - If CopyEditorAgent responded, we're done (return "COMPLETE")
            
            RESPONSE:
            {{$lastmessage}}
            """,
            safeParameterNames: "lastmessage"
        );

        // Termination after CopyEditor finishes
        KernelFunction terminationFunction = AgentGroupChat.CreatePromptFunctionForStrategy(
            """
            Check if CopyEditorAgent has finished polishing the blog post.
            If the RESPONSE is from CopyEditorAgent with a complete blog post, respond with: TERMINATE
            Otherwise continue.
            
            RESPONSE:
            {{$lastmessage}}
            """,
            safeParameterNames: "lastmessage"
        );

        // Create the agent group chat
        AgentGroupChat chat = new(writerAgent, copyEditorAgent)
        {
            ExecutionSettings = new AgentGroupChatSettings
            {
                SelectionStrategy = new KernelFunctionSelectionStrategy(selectionFunction, kernel)
                {
                    InitialAgent = writerAgent,
                    ResultParser = (result) =>
                    {
                        var selectedAgent = result.GetValue<string>()?.Trim() ?? writerAgent.Name;
                        if (selectedAgent.Contains("COMPLETE")) return null; // End conversation
                        Console.WriteLine($"üîÑ Next Agent: {selectedAgent}");
                        return selectedAgent;
                    }
                },
                TerminationStrategy = new KernelFunctionTerminationStrategy(terminationFunction, kernel)
                {
                    Agents = [copyEditorAgent],
                    MaximumIterations = 3, // Writer -> CopyEditor -> Done
                    ResultParser = (result) =>
                        result.GetValue<string>()?.Contains("TERMINATE", StringComparison.OrdinalIgnoreCase) ?? false
                }
            }
        };

        // Process Word documents
        var docxFiles = Directory.GetFiles(draftsFolder, "*.docx")
            .Where(f => !Path.GetFileName(f).StartsWith("~$"))
            .ToArray();

        if (docxFiles.Length == 0)
        {
            Console.WriteLine("üìù No Word documents found in drafts folder.");
            return;
        }

        Directory.CreateDirectory(finalDraftFolder);

        foreach (var docxFile in docxFiles)
        {
            Console.WriteLine($"\nüéØ Processing: {Path.GetFileName(docxFile)}");
            await ProcessDocumentWithTwoAgentsAsync(chat, docxFile, finalDraftFolder);
        }
    }

    private static async Task ProcessDocumentWithTwoAgentsAsync(AgentGroupChat chat, string docxPath, string outputFolder)
    {
        try
        {
            // Extract Word document content
            var content = ExtractWordContent(docxPath);
            Console.WriteLine($"üìñ Extracted {content.Length} characters");

            // Step 1: Writer Agent creates the blog post
            Console.WriteLine("üìù Step 1: WriterAgent creating blog post...");
            var writerAgent = (ChatCompletionAgent)chat.Agents.First(a => a.Name == "WriterAgent");
            var writerService = writerAgent.Kernel.GetRequiredService<IChatCompletionService>();
            
            var writerPrompt = CreateWriterPrompt(content);
            var writerResponse = await writerService.GetChatMessageContentAsync(writerPrompt);
            
            if (string.IsNullOrEmpty(writerResponse?.Content))
            {
                Console.WriteLine("‚ùå WriterAgent failed to generate content");
                return;
            }

            Console.WriteLine($"‚úÖ WriterAgent completed ({writerResponse.Content.Length} characters)");

            // Step 2: CopyEditor Agent polishes the blog post
            Console.WriteLine("‚úèÔ∏è Step 2: CopyEditorAgent polishing for grammar and readability...");
            var editorAgent = (ChatCompletionAgent)chat.Agents.First(a => a.Name == "CopyEditorAgent");
            var editorService = editorAgent.Kernel.GetRequiredService<IChatCompletionService>();
            
            var editorPrompt = CreateEditorPrompt(writerResponse.Content);
            var finalResponse = await editorService.GetChatMessageContentAsync(editorPrompt);
            
            if (string.IsNullOrEmpty(finalResponse?.Content))
            {
                Console.WriteLine("‚ö†Ô∏è CopyEditor failed, using WriterAgent output");
                finalResponse = writerResponse;
            }

            Console.WriteLine($"‚úÖ CopyEditorAgent completed ({finalResponse.Content.Length} characters)");

            // Save the final result
            var fileName = $"BLOG_2AGENT_{DateTime.Now:yyyyMMdd_HHmmss}_{Path.GetFileNameWithoutExtension(docxPath)}.md";
            var outputPath = Path.Combine(outputFolder, fileName);
            
            await File.WriteAllTextAsync(outputPath, finalResponse.Content);
            
            Console.WriteLine($"‚úÖ Two-agent blog completed: {fileName}");
            Console.WriteLine($"üìÅ Saved to: {outputPath}");

            // Archive the original
            var archivePath = Path.ChangeExtension(docxPath, ".twoagent.processed.docx");
            File.Move(docxPath, archivePath);
            Console.WriteLine($"üì¶ Original archived: {Path.GetFileName(archivePath)}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Error processing {Path.GetFileName(docxPath)}: {ex.Message}");
        }
    }

    private static ChatCompletionAgent CreateWriterAgent(Kernel kernel, string template)
    {
        var today = DateTime.Now.ToString("yyyy-MM-dd");
        
        return new ChatCompletionAgent()
        {
            Name = "WriterAgent",
            Instructions = $"""
                You are a skilled technical writer specializing in Fabian Williams' blog style.

                TEMPLATE STYLE TO FOLLOW:
                {template.Substring(0, Math.Min(1000, template.Length))}...

                YOUR TASK:
                1. Transform Word document content into a complete blog post
                2. Use Hugo frontmatter (+++), author "Fabian Williams", date "{today}"
                3. Apply emoji headers consistently (üöÄ üõ†Ô∏è üß† üìã üéØ)
                4. Write in Fabian's conversational yet technical style
                5. Include code examples and practical advice where relevant

                Keep it focused and complete - the CopyEditor will handle grammar/readability.
                """,
            Kernel = kernel
        };
    }

    private static ChatCompletionAgent CreateCopyEditorAgent(Kernel kernel)
    {
        return new ChatCompletionAgent()
        {
            Name = "CopyEditorAgent", 
            Instructions = """
                You are an expert copy editor focused on clarity and accessibility.

                YOUR ROLE:
                1. Polish the blog post for grammar, spelling, and punctuation
                2. Ensure readability at a 1st-year college level
                3. Maintain the technical accuracy and original intent
                4. Keep Fabian's authentic voice and style intact
                5. Fix any markdown formatting issues

                IMPORTANT: Never remove technical content or change the core message.
                Your job is to make it clearer and more readable, not to change the substance.
                The original intent should always be preserved.

                Output the complete, polished blog post ready for publication.
                """,
            Kernel = kernel
        };
    }

    private static Kernel CreateKernel()
    {
        var builder = Kernel.CreateBuilder();
        
        var baseUrl = _configuration?["Ollama:BaseUrl"] ?? "http://localhost:11434";
        var modelId = _configuration?["Ollama:ModelId"] ?? "gpt-oss:120b";
        
        Console.WriteLine($"üîó Connecting to {baseUrl} with model {modelId}");
        
        builder.AddOllamaChatCompletion(modelId: modelId, endpoint: new Uri(baseUrl));
        
        return builder.Build();
    }

    private static async Task<string> LoadTemplateAsync(string templateFolder)
    {
        try
        {
            if (!Directory.Exists(templateFolder))
            {
                return "Use Hugo blog format with emoji headers and frontmatter.";
            }

            var templateFiles = Directory.GetFiles(templateFolder, "*.md");
            if (templateFiles.Length == 0)
            {
                return "Use Hugo blog format with emoji headers and frontmatter.";
            }

            var template = await File.ReadAllTextAsync(templateFiles.First());
            Console.WriteLine($"üìã Loaded template: {Path.GetFileName(templateFiles.First())}");
            return template;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ö†Ô∏è Template load failed: {ex.Message}");
            return "Use Hugo blog format with emoji headers and frontmatter.";
        }
    }

    private static string CreateWriterPrompt(string content)
    {
        var today = DateTime.Now.ToString("yyyy-MM-dd");
        return $"""
            Transform this Word document content into a blog post in Fabian Williams' style:
            
            CONTENT:
            {content.Substring(0, Math.Min(1500, content.Length))}...
            
            REQUIREMENTS:
            - Hugo frontmatter with +++, author "Fabian Williams", date "{today}"
            - Emoji headers (üöÄ üõ†Ô∏è üß† üìã üéØ)
            - Technical but conversational tone
            - Include code examples and practical advice
            - Complete markdown blog post
            """;
    }

    private static string CreateEditorPrompt(string blogContent)
    {
        return $"""
            Polish this blog post for grammar, spelling, and 1st-year college readability while preserving all technical content and the original intent:
            
            BLOG POST TO EDIT:
            {blogContent}
            
            COPYEDIT RULES:
            - Fix grammar, spelling, punctuation errors
            - Ensure 1st-year college reading level
            - Keep ALL technical content intact
            - Preserve Fabian's authentic voice
            - Fix markdown formatting if needed
            - NEVER remove or change the core message
            
            Output the complete, polished blog post:
            """;
    }

    private static string ExtractBlogContent(List<string> responses)
    {
        // Get the final response (should be from CopyEditor)
        var finalResponse = responses.LastOrDefault() ?? "";
        
        // Look for Hugo frontmatter to extract the blog content
        if (finalResponse.Contains("+++"))
        {
            var lines = finalResponse.Split('\n');
            var contentStart = -1;
            
            for (int i = 0; i < lines.Length; i++)
            {
                if (lines[i].Trim().StartsWith("+++"))
                {
                    contentStart = i;
                    break;
                }
            }
            
            if (contentStart >= 0)
            {
                return string.Join('\n', lines[contentStart..]);
            }
        }
        
        return finalResponse;
    }

    private static string ExtractWordContent(string docxPath)
    {
        try
        {
            using var doc = WordprocessingDocument.Open(docxPath, false);
            var body = doc.MainDocumentPart?.Document?.Body;
            
            if (body == null) return "Could not extract content.";

            var content = new StringBuilder();
            
            foreach (var element in body.Elements())
            {
                if (element is Paragraph paragraph)
                {
                    var text = GetParagraphText(paragraph);
                    if (!string.IsNullOrWhiteSpace(text))
                    {
                        content.AppendLine(text);
                        content.AppendLine();
                    }
                }
                else if (element is Table table)
                {
                    content.AppendLine("[TABLE CONTENT]");
                    foreach (var row in table.Elements<TableRow>())
                    {
                        var cells = row.Elements<TableCell>()
                            .Select(cell => string.Join(" ", cell.Elements<Paragraph>()
                                .Select(p => GetParagraphText(p))
                                .Where(t => !string.IsNullOrWhiteSpace(t))))
                            .Where(t => !string.IsNullOrWhiteSpace(t));
                        
                        if (cells.Any())
                        {
                            content.AppendLine("| " + string.Join(" | ", cells) + " |");
                        }
                    }
                    content.AppendLine("[/TABLE]");
                    content.AppendLine();
                }
            }

            return content.ToString();
        }
        catch (Exception ex)
        {
            return $"Error extracting Word content: {ex.Message}";
        }
    }

    private static string GetParagraphText(Paragraph paragraph)
    {
        var text = new StringBuilder();
        foreach (var run in paragraph.Elements<Run>())
        {
            foreach (var textElement in run.Elements<Text>())
            {
                text.Append(textElement.Text);
            }
        }
        return text.ToString().Trim();
    }
}